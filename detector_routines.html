<!-- This file was generated by mk_html_help.pro -->
<html>
 
<head>
<TITLE>CARS Detector-Related Routines</TITLE>
</head>
 
<body>
<H1>CARS Detector-Related Routines</H1>
<P>
This page was created by the IDL library routine 
<CODE>mk_html_help</CODE>.  For more information on 
this routine, refer to the IDL Online Help Navigator 
or type: <P>
<PRE>     ? mk_html_help</PRE><P>
at the IDL command line prompt.<P>
<STRONG>Last modified: </STRONG>Wed Jun 28 11:14:00 2017.<P>
 
<HR>
 
<A NAME="ROUTINELIST">
<H1>List of Routines</H1></A>
<UL>
<LI><A HREF="#BAS2000_RESPONSE">BAS2000_RESPONSE</A>
<LI><A HREF="#DECODE_FALCON_BUFFERS">DECODE_FALCON_BUFFERS</A>
<LI><A HREF="#DECODE_XMAP_BUFFERS">DECODE_XMAP_BUFFERS</A>
<LI><A HREF="#READ_BAS2000">READ_BAS2000</A>
<LI><A HREF="#READ_MAR345">READ_MAR345</A>
<LI><A HREF="#READ_MARCCD">READ_MARCCD</A>
<LI><A HREF="#READ_ND_NETCDF">READ_ND_NETCDF</A>
<LI><A HREF="#READ_PHANTOM">READ_PHANTOM</A>
<LI><A HREF="#READ_PHOTOMETRICS">READ_PHOTOMETRICS</A>
<LI><A HREF="#READ_PRINCETON">READ_PRINCETON</A>
<LI><A HREF="#READ_PXL">READ_PXL</A>
<LI><A HREF="#READ_SIEMENS">READ_SIEMENS</A>
<LI><A HREF="#READ_WDX">READ_WDX</A>
<LI><A HREF="#READ_XMAP_2D">READ_XMAP_2D</A>
<LI><A HREF="#READ_XMAP_NETCDF">READ_XMAP_NETCDF</A>
<LI><A HREF="#WINX32_CCD::BUSY">WINX32_CCD::BUSY</A>
<LI><A HREF="#WINX32_CCD::CLOSEDOCFILE">WINX32_CCD::CLOSEDOCFILE</A>
<LI><A HREF="#WINX32_CCD::DOCFILEVALID">WINX32_CCD::DOCFILEVALID</A>
<LI><A HREF="#WINX32_CCD::GETDATA">WINX32_CCD::GETDATA</A>
<LI><A HREF="#WINX32_CCD::GETDOCFILEPROPERTY">WINX32_CCD::GETDOCFILEPROPERTY</A>
<LI><A HREF="#WINX32_CCD::GETEXPCMDPROPERTY">WINX32_CCD::GETEXPCMDPROPERTY</A>
<LI><A HREF="#WINX32_CCD::GETPROPERTY">WINX32_CCD::GETPROPERTY</A>
<LI><A HREF="#WINX32_CCD::INIT">WINX32_CCD::INIT</A>
<LI><A HREF="#WINX32_CCD::SAVE">WINX32_CCD::SAVE</A>
<LI><A HREF="#WINX32_CCD::SETDOCFILEPROPERTY">WINX32_CCD::SETDOCFILEPROPERTY</A>
<LI><A HREF="#WINX32_CCD::SETEXPCMDPROPERTY">WINX32_CCD::SETEXPCMDPROPERTY</A>
<LI><A HREF="#WINX32_CCD::SETPROPERTY">WINX32_CCD::SETPROPERTY</A>
<LI><A HREF="#WINX32_CCD::START">WINX32_CCD::START</A>
<LI><A HREF="#WINX32_CCD::STOP">WINX32_CCD::STOP</A>
<LI><A HREF="#WINX32_CCD__DEFINE">WINX32_CCD__DEFINE</A>
<LI><A HREF="#WINX32_DM_CMD_INIT">WINX32_DM_CMD_INIT</A>
<LI><A HREF="#WINX32_DM_CMD__DEFINE">WINX32_DM_CMD__DEFINE</A>
<LI><A HREF="#WINX32_EXP_CMD_INIT">WINX32_EXP_CMD_INIT</A>
<LI><A HREF="#WINX32_EXP_CMD__DEFINE">WINX32_EXP_CMD__DEFINE</A>
<LI><A HREF="#WRITE_BAS2000">WRITE_BAS2000</A>
<LI><A HREF="#WRITE_PRINCETON">WRITE_PRINCETON</A>
</UL><P>
 
<HR>
 
<H1>Routine Descriptions</H1>
<A NAME="BAS2000_RESPONSE">
<H2>BAS2000_RESPONSE</H2></A>
<A HREF="#DECODE_FALCON_BUFFERS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   BAS2000_RESPONSE

 PURPOSE:
   This function converts values measured by the BAS2000 scanner into
   actual x-ray intensities.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   Results = BAS2000_RESPONSE(Settings, Data)

 INPUTS:
   Settings:  
       A structure of BAS2000 instrument settings of the type created by 
       READ_BAS2000.

   Data:
       Raw data values such as those read by READ_BAS2000.  This can be either
       a single value or an array of values.

 OUTPUTS:
   This function returns the actual x-ray intensities corresponding to the
   raw input values.

 PROCEDURE:
   This function converts values measured by the BAS2000 scanner into
   actual x-ray intensities according to the equation:

       PSL = (4000/S)*10^(L*QSL)/1023 - 0.5)
   where
       PSL = x-ray intensity
       S   = sensitivity setting
       L   = latitude setting
       QSL = measured value from BAS2000

   This equation appears somewhere in the BAS2000 documentation?
   
 EXAMPLE:
   READ_BAS2000, 'Myfile', settings, data
   Actual = BAS2000_RESPONSE(settings, data)

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, 1997?
   Modifications:
       MLR 26-APR-1999 Added documentation header
</PRE><P>
<STRONG>(See bas2000_response.pro)</STRONG><P>
<HR>
 
<A NAME="DECODE_FALCON_BUFFERS">
<H2>DECODE_FALCON_BUFFERS</H2></A>
<A HREF="#BAS2000_RESPONSE">[Previous Routine]</A>
<A HREF="#DECODE_XMAP_BUFFERS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   DECODE_FALCON_BUFFERS

 PURPOSE:
   This function parses the buffers collected with the XIA Falcon modules in MCA mapping mode.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   Data = DECODE_FALCON_BUFFERS(BufferData)

 INPUTS:
   BufferData:
       An array containing the buffer data.  This array will typically have been read with the READ_ND_NETCDF
       function, but it could also have been created in other ways.  This array is of type INT, i.e. 16-bit
       data.  Its dimensions are [BufferSize, NumChannels, NumArrays].  
       NumArrays is the number of arrays that were collected.  
       NumChannels is the number of detectors in the system (i.e. 1, 2, 4, etc.)
       BufferSize is the size of each buffer that was read from the Falcon.

 OUTPUTS:
       This function returns a structure with the decoded data from the buffer array.  The structure
       definition depends on the mapping mode that was used to collect the data.  

       In MCA mapping mode the structure is the following:
           FalconData = {FalconData, $
               firstPixel:    0L,        $
               numPixels:     0L,        $
               pData:         ptr_new(), $
               pRealTime:     ptr_new(), $
               pLiveTime:     ptr_new(), $
               pInputCounts:  ptr_new(), $
               pOutputCounts: ptr_new() $
           }
           firstPixel is the number of the first pixel in the first array
           numPixels is the total number of pixels in the output arrays
           pData is a pointer to the MCA spectra array.
           The dimensions of this array in MCA mapping mode is [numChannels, numDetectors, numPixels] 
           pRealTime is a pointer to an array of real time at each pixel, [numDetectors, numPixels] 
           pLiveTime is a pointer to an array of live time at each pixel, [numDetectors, numPixels] 
           pInputCounts is a pointer to an array of trigger counts at each pixel, [numDetectors, numPixels] 
           pOutputCounts is a pointer to an array of event counts at each pixel, [numDetectors, numPixels] 


 EXAMPLES:
   This is an example of decoding the buffers for MCA mapping mode data:
   IDL> buff = read_nd_netcdf('mca_mapping_001.nc')
   IDL> help, buff
   BUFF            INT       = Array[1047808, 4, 9]
   IDL> d = decode_xmap_buffers(buff)
   IDL> help, /structure, d
   ** Structure XMAPDATA, 7 tags, length=28, data length=28:
      FIRSTPIXEL      LONG                 0
      NUMPIXELS       LONG              1000
      PDATA           POINTER   <PtrHeapVar3>
      PREALTIME       POINTER   <PtrHeapVar4>
      PLIVETIME       POINTER   <PtrHeapVar5>
      PINPUTCOUNTS    POINTER   <PtrHeapVar6>
      POUTPUTCOUNTS   POINTER   <PtrHeapVar7>
   IDL> help, *d.pData     
   <PtrHeapVar3>   INT       = Array[2048, 16, 1116]
   IDL> help, *d.pRealTime
   <PtrHeapVar4>   FLOAT     = Array[16, 1116]



 MODIFICATION HISTORY:
   Written by:     Mark Rivers, May 10, 2017
</PRE><P>
<STRONG>(See decode_falcon_buffers.pro)</STRONG><P>
<HR>
 
<A NAME="DECODE_XMAP_BUFFERS">
<H2>DECODE_XMAP_BUFFERS</H2></A>
<A HREF="#DECODE_FALCON_BUFFERS">[Previous Routine]</A>
<A HREF="#READ_BAS2000">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   DECODE_XMAP_BUFFERS

 PURPOSE:
   This function parses the buffers collected with the XIA xMAP or Mercury modules in one of the mapping modes.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   Data = DECODE_XMAP_BUFFERS(BufferData)

 INPUTS:
   BufferData:
       An array containing the buffer data.  This array will typically have been read with the READ_ND_NETCDF
       function, but it could also have been created in other ways.  This array is of type INT, i.e. 16-bit
       data.  Its dimensions are [BufferSize, NumArrays, NumModules].  NumArrays is the number of arrays
       that were collected.  NumModules is the number of xMAP modules in the system.  BufferSize is the size
       of each buffer that was read from the xMAP.

 OUTPUTS:
       This function returns a structure with the decoded data from the buffer array.  The structure
       definition depends on the mapping mode that was used to collect the data.  

       In MCA mapping and SCA mapping modes the structure is the following:
           xMAPData = {xMAPData, $
               firstPixel:    0L,        $
               numPixels:     0L,        $
               pData:         ptr_new(), $
               pRealTime:     ptr_new(), $
               pLiveTime:     ptr_new(), $
               pInputCounts:  ptr_new(), $
               pOutputCounts: ptr_new() $
           }
           firstPixel is the number of the first pixel in the first array
           numPixels is the total number of pixels in the output arrays
           pData is a pointer to the MCA spectra (MCA mapping mode) or SCA counts (SCA mapping mode) array.
           The dimensions of this array in MCA mapping mode is [numChannels, numDetectors, numPixels] 
           The dimensions of this array in SCA mapping mode is [numSCAs, numDetectors, numPixels] 
           pRealTime is a pointer to an array of real time at each pixel, [numDetectors, numPixels] 
           pLiveTime is a pointer to an array of live time at each pixel, [numDetectors, numPixels] 
           pInputCounts is a pointer to an array of trigger counts at each pixel, [numDetectors, numPixels] 
           pOutputCounts is a pointer to an array of event counts at each pixel, [numDetectors, numPixels] 

       In List mapping mode the structure is the following:
           xMAPListData = {xMAPListData, $
               listMode:      0L,        $
               pData:         ptr_new(), $
               pPixelClock:   ptr_new(), $
               pNumEvents:    ptr_new(), $
               pRealTime:     ptr_new(), $
               pLiveTime:     ptr_new(), $
               pInputCounts:  ptr_new(), $
               pOutputCounts: ptr_new() $
           }
           listMode is the list mode variant (Gate, Sync, or Clock) of this data
           pData is a pointer to the event mode data array.
           The dimensions of this array is [maxEvents*numArrays, numModules].  This array
           contains the energy of each event in bits 0-12, and the detector number (0-3) in bits 13-14.
           pPixelClock is a point to an array of pixel clock information.  In Gate or Sync variants this
           is the pixel number of each event.  In Clock variant this is the clock time in ticks of the 50MHz
           system clock since acquisition was started.  Dimensions = [maxEvents*numArrays, numModules]
           pNumEvents is a pointer to an array containing the number of actual events in each the first
           dimension of the pData array for each module. Dimensions = [numDetectors, numArrays]
           pRealTime is a pointer to an array of real time at each pixel, [numDetectors, numArrays] 
           pLiveTime is a pointer to an array of live time at each pixel, [numDetectors, numArrays] 
           pInputCounts is a pointer to an array of trigger counts at each pixel, [numDetectors, numArrays] 
           pOutputCounts is a pointer to an array of event counts at each pixel, [numDetectors, numArrays] 

 EXAMPLES:
   This is an example of decoding the buffers for MCA mapping mode data:
   IDL> buff = read_nd_netcdf('mca_mapping_001.nc')
   IDL> help, buff
   BUFF            INT       = Array[1047808, 4, 9]
   IDL> d = decode_xmap_buffers(buff)
   IDL> help, /structure, d
   ** Structure XMAPDATA, 7 tags, length=28, data length=28:
      FIRSTPIXEL      LONG                 0
      NUMPIXELS       LONG              1000
      PDATA           POINTER   <PtrHeapVar3>
      PREALTIME       POINTER   <PtrHeapVar4>
      PLIVETIME       POINTER   <PtrHeapVar5>
      PINPUTCOUNTS    POINTER   <PtrHeapVar6>
      POUTPUTCOUNTS   POINTER   <PtrHeapVar7>
   IDL> help, *d.pData     
   <PtrHeapVar3>   INT       = Array[2048, 16, 1116]
   IDL> help, *d.pRealTime
   <PtrHeapVar4>   FLOAT     = Array[16, 1116]

   This is an example of decoding the buffers for SCA mapping mode data:
   IDL> buff = read_nd_netcdf('sca_mapping_001.nc')
   IDL> help, buff                                 
   BUFF            INT       = Array[1048320, 4]
   IDL> d = decode_xmap_buffers(buff)              
   IDL> help, /structure, d                        
   ** Structure XMAPDATA, 7 tags, length=28, data length=28:
      FIRSTPIXEL      LONG                 0
      NUMPIXELS       LONG              1000
      PDATA           POINTER   <PtrHeapVar10>
      PREALTIME       POINTER   <PtrHeapVar11>
      PLIVETIME       POINTER   <PtrHeapVar12>
      PINPUTCOUNTS    POINTER   <PtrHeapVar13>
      POUTPUTCOUNTS   POINTER   <PtrHeapVar14>
   IDL> help, *d.pData                             
   <PtrHeapVar10>  LONG      = Array[8, 16, 1000]
   IDL> help, *d.pRealTime                         
   <PtrHeapVar11>  FLOAT     = Array[16, 1000]

   This is an example of decoding the buffers for List Sync mode data:
   IDL> buff = read_nd_netcdf('list_mapping_sync_001.nc')
   IDL> help, buff                                       
   BUFF            INT       = Array[1048576, 4]
   IDL> d = decode_xmap_buffers(buff)                    
   IDL> help, /structure, d                              
   ** Structure XMAPLISTDATA, 8 tags, length=32, data length=32:
      LISTMODE        LONG                 1
      PDATA           POINTER   <PtrHeapVar17>
      PPIXELCLOCK     POINTER   <PtrHeapVar18>
      PNUMEVENTS      POINTER   <PtrHeapVar19>
      PREALTIME       POINTER   <PtrHeapVar20>
      PLIVETIME       POINTER   <PtrHeapVar21>
      PINPUTCOUNTS    POINTER   <PtrHeapVar22>
      POUTPUTCOUNTS   POINTER   <PtrHeapVar23>
   IDL> help, *d.pData                                   
   <PtrHeapVar17>  INT       = Array[349525, 4]
   IDL> help, *d.pPixelClock
   <PtrHeapVar18>  LONG      = Array[349525, 4]
   IDL> help, *d.pRealTime
   <PtrHeapVar20>  FLOAT     = Array[16]
   IDL> h = histogram((*d.pData) and 8191)
   IDL> iplot, h, yrange=[1,1e3], /ylog

   This is an example of decoding the buffers for List Sync mode data:
   IDL> buff = read_nd_netcdf('list_mapping_clock_001.nc')
   IDL> help, buff                                        
   BUFF            INT       = Array[1048576, 4]
   IDL> d = decode_xmap_buffers(buff)                     
   IDL> help, /structure, d                               
   ** Structure XMAPLISTDATA, 8 tags, length=32, data length=32:
      LISTMODE        LONG                 2
      PDATA           POINTER   <PtrHeapVar23647>
      PPIXELCLOCK     POINTER   <PtrHeapVar23648>
      PNUMEVENTS      POINTER   <PtrHeapVar23649>
      PREALTIME       POINTER   <PtrHeapVar23650>
      PLIVETIME       POINTER   <PtrHeapVar23651>
      PINPUTCOUNTS    POINTER   <PtrHeapVar23652>
      POUTPUTCOUNTS   POINTER   <PtrHeapVar23653>
   IDL> print, (*d.pPixelClock)[0:49]
          16597       16597       16597       21414       21414       21414
          58937       58937       58937       63590       63590       63590
          86560       86560       86560      106343      106343      106343
         114362      114362      114362      120760      120760      120760
         135015      135015      135015      157845      174007      174007
         174007      174845      174845      193928      193928      193928
         198542      225748      225748      225748      238293      238293
         238293      281407      344284      349105      349105      349105
         355190      355190
 The above are the pixel clock values in units of 20 ns ticks
 IDL> print, (*d.pData)[0:49]      
       9735   17934   26123    9746   17946   26134    9748   17948   26138 26322
       9934   18135    9735   17935   26118   17947   26135    9745    8477 16671
      24861    9939   18141   26328   26105    9716   17918    1476   17920 26105
       9719    9745   17946    9745   17946   26133    1308    9745   17946 26134
      26108    9720   17921    1470    1474    9718   17919   26106    9753 17958
 The above are the energy values of the first 50 events.  Bits 13-14 contain the detector number
 IDL> print, (*d.pData)[0:49] and 8191
       1543    1550    1547    1554    1562    1558    1556    1564    1562    1746
       1742    1751    1543    1551    1542    1563    1559    1553     285      87
        285    1747    1757    1752    1529    1524    1534    1476    1536    1529
       1527    1553    1562    1553    1562    1557    1308    1553    1562    1558
       1532    1528    1537    1470    1474    1526    1535    1530    1561    1574
 The above are the energy values of the first 50 events with bits 13-14 masked off.


 MODIFICATION HISTORY:
   Written by:     Mark Rivers, July 2010
</PRE><P>
<STRONG>(See decode_xmap_buffers.pro)</STRONG><P>
<HR>
 
<A NAME="READ_BAS2000">
<H2>READ_BAS2000</H2></A>
<A HREF="#DECODE_XMAP_BUFFERS">[Previous Routine]</A>
<A HREF="#READ_MAR345">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_BAS2000

 PURPOSE:
   This procedure reads data files from the Fuji BAS2000 image plate scanner.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   READ_BAS2000, File, Settings, Data

 INPUTS:
   File:
       The name of the input file without the '.inf' or '.img' extensions.

 OUTPUTS:
   Settings:
       A structure which contains the instrument settings for the scanner.
       The names of the fields in this structure are meant to be
       self-explanatory.

   Data:
       The 2-D array of intensities.  This is either an 8-bit BYTE array or
       a 16-bit INT array depending upon the setting of the scanner when
       the file was written.

 RESTRICTIONS:
   This procedure requires at least IDL 5.1 because it uses the
   SWAP_IF_LITTLE_ENDIAN keyword to BYTEORDER.

 EXAMPLE:
   READ_BAS2000, 'Myfile', settings, data

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, 1993?
   Modifications:
       MLR 20-AUG-1998 Changed to use SWAP_IF_LITTLE_ENDIAN on BYTEORDER.
       MLR 26-APR-1999 Added documentation header
       MLR 21-JUL-1999 Fixed bug, replace CLOSE, lun with FREE_LUN, lun
       MLR 08-NOV-2001 Changes to allow reading BAS2500.  Used unsigned int
                       for 16 bit data, BAS2500 does not have #saturated pixels
                       in .inf file.
</PRE><P>
<STRONG>(See read_bas2000.pro)</STRONG><P>
<HR>
 
<A NAME="READ_MAR345">
<H2>READ_MAR345</H2></A>
<A HREF="#READ_BAS2000">[Previous Routine]</A>
<A HREF="#READ_MARCCD">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_MAR345

 PURPOSE:
   This procedures reads a MAR 345 image plate file.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   READ_MAR345, File, Data, Header

 INPUTS:
   File:
       The name of the MAR345 input file.

 OUTPUTS:
   Data:
       The 2-D array of intensities.  This is a 16-bit UINT array if the data
       does not contain any high pixels (>65535) , and LONG if the data does contain
       any high pixels.

   Header:
       A structure which contains the header information.
       The names of the fields in this structure are meant to be
       self-explanatory.

 OPERATION:
   This routine uses IDL to read the header information and the table
   of high pixel values (if present).

   It can also use IDL to read and decompress the data, but this is quite slow,
   about 90 seconds for a 3450x3450 image.

   To improve performance there is a C code function provided that can read the files
   and decompress them much faster, about 2 seconds for a 3450x3450 image.
   This C code is built into a shareable object or DLL which is called from IDL.
   Prebuilt shareable libraries are provided for Linux (mar345_IDL.so) and
   Windows (mar345_IDL.dll). The source code (mar345_IDL.c) and Makefile for Linux and Unix,
   and a .bat file to build on Windows are also provided in this directory.
   The required support files, mar3xx_pck.c and mar3xx_pck.h are also provided.

   At run time this IDL routine will see if there is an environment variable
   called MAR345_IDL.  If it exists, it is assumed to be the complete path specification
   to a shareable library. If the environment variable does not exist or does not
   point to a valid file, then the routine will search the IDL_PATH for mar345_IDL.dll
   (on Windows) or mar345_IDL.so (all other operating systems).  If the shareable
   object is found then read_mar345.pro will call that shareable library to read and
   decompress the file.  If the shareable object is not found then the built-in IDL
   code will be used instead, which is quite slow.

 EXAMPLE:
   READ_MAR345, 'Myfile.mar345', data, header

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, 2006
   Modifications:
</PRE><P>
<STRONG>(See read_mar345.pro)</STRONG><P>
<HR>
 
<A NAME="READ_MARCCD">
<H2>READ_MARCCD</H2></A>
<A HREF="#READ_MAR345">[Previous Routine]</A>
<A HREF="#READ_ND_NETCDF">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_MARCCD

 PURPOSE:
   This procedures reads a MAR-CCD format file

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   READ_MARCCD, File, Data, Header

 INPUTS:
   File:
       The name of the MAR-CCD input file.

 OUTPUTS:
   Data:
       The 2-D array of intensities.  This is a 16-bit UINT array

   Header:
       A structure which contains the header information.
       The names of the fields in this structure are meant to be
       self-explanatory.

 EXAMPLE:
   IDL> READ_MARCCD, 'MgO_090.tif', data, header
   IDL> print, header.exposure_time
        60178

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, March 21, 2006
</PRE><P>
<STRONG>(See read_marccd.pro)</STRONG><P>
<HR>
 
<A NAME="READ_ND_NETCDF">
<H2>READ_ND_NETCDF</H2></A>
<A HREF="#READ_MARCCD">[Previous Routine]</A>
<A HREF="#READ_PHANTOM">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_ND_NETCDF

 PURPOSE:
   This function reads a netCDF file written by the NDPluginFile plugin in the areaDetector module.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   Data = READ_ND_NETCDF(File, Range=Range, Attributes=Attributes, DimInfo=DimInfo, NoData=NoData)

 INPUTS:
   File:
       The name of the input file.  If this argument is missing then the dialog_pickfile() function
       will be called to produce a file browser to select a file interactively.

 KEYWORD INPUTS:
  Range:
       The range to read for each dimension.  If this keyword is missing then the entire file is read.
       Specify as a 2D array.  [-1,-1] for any dimension means the
       full value in the file. Only dimensions up to the last one to be limited need to be included
       in the array, i.e. for a 2-D array range=[[0,10]] is equivalent to range=[[0,10],[-1,-1]]
       Examples:
         range=[[-1,-1], [0,100], [2,5]]
       means read the full range of the data in the first (fastest) dimension, elements 0 to 100 for
       the second dimension and elements 2 to 5 for the last (slowest) dimension.
  NoData:
       Set this keyword to 1 to not read the data itself, but only the attributes and dimension info.

 OUTPUTS:
       This function returns the N-Dimensional array of data.
       The dimensions are [dim0, dim1, ..., NumArrays]
       If the NoData keyword is set then the function just returns 0.

 KEYWORD OUTPUTS:
   Attributes: An array of structures of the following type containing the name, description and pointer to value
           for each additional variable (NDArray attribute) in the file:
           attrInfo = {netCDFAttrInfo, $
                       name:    "", $
                       description: "", $
                       pValue:  ptr_new()}


   DimInfo: An array of structures of the following type containing the size, offset, binning and reverse fields
            for each dimension:
            dimInfo = {netCDFDimInfo, $
                       size:    0L, $
                       offset:  0L, $
                       binning: 0L, $
                       reverse:  0L}

 EXAMPLE:

 IDL> data = read_nd_netcdf('/home/epics/scratch/test_color_70.nc', attributes=attributes, dimInfo=dimInfo)

 IDL> help, data
 DATA            BYTE      = Array[3, 640, 480, 50]

 IDL> help, /structure, dimInfo
 ** Structure NETCDFDIMINFO, 4 tags, length=16, data length=16:
    SIZE            LONG                 3
    OFFSET          LONG                 0
    BINNING         LONG                 1
    REVERSE         LONG                 0

 IDL> help, /structure, attributes[3]
 ** Structure NETCDFATTRINFO, 3 tags, length=28, data length=28:
   NAME            STRING    'I8Value'
   DESCRIPTION     STRING    'Signed 8-bit time'
   PVALUE          POINTER   <PtrHeapVar249>

 IDL> print, attributes[10].name
 F64Value

 IDL> help, *attributes[10].pValue
 <PtrHeapVar256> DOUBLE    = Array[50]

 IDL> print, (*attributes[10].pValue)[0:9], format='(f20.10)'
 609361297.6659992933
 609361297.6907505989
 609361297.7110251188
 609361297.7338150740
 609361297.7543159723
 609361297.7819019556
 609361297.8048160076
 609361297.8250850439
 609361297.8466095924
 609361297.8699282408

 Read just a subset of the array data.  Arrays 30-39, complete data in the other dimensions
 IDL> data = read_nd_netcdf('/home/epics/scratch/test_color_70.nc', attributes=attributes, dimInfo=dimInfo, $
                           range=[[-1,-1],[-1,-1],[-1,-1],[30,39]])
 IDL> help, data
 DATA            BYTE      = Array[3, 640, 480, 10]

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, April 17, 2008
   January 25, 2009 Mark Rivers Added arrayInfo support and RANGE keyword to read only a subset of the data
                    Changed uniqueId, timeStamp and dimInfo to be keyword rather than positional
   April 23, 2009  Mark Rivers.  Added support for new file format with NDArray attributes.  Removed uniqueId and timeStamp
                   keywords, these are now handled under general attributes.  colorMode and bayerPattern no longer
                   returned in arrayInfo structure, they are also general attributes of each array.
   March 26, 2016  Mark Rivers.  Added NoData keyword.
</PRE><P>
<STRONG>(See read_nd_netcdf.pro)</STRONG><P>
<HR>
 
<A NAME="READ_PHANTOM">
<H2>READ_PHANTOM</H2></A>
<A HREF="#READ_ND_NETCDF">[Previous Routine]</A>
<A HREF="#READ_PHOTOMETRICS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_PHANTOM

 PURPOSE:
   Reads in data files written by the Vision Research Phantom high-speed cameras.

 CATEGORY:
   Detectors

 CALLING SEQUENCE:
   Result = READ_PHANTOM(File)

 INPUTS:
   File:
       The name of the volume file to be read.  If this is not specified then
       the function will use DIALOG_PICKFILE to allow the user to select a
       file.
 KEYWORD PARAMETERS:
   XRANGE=[xstart, xstop]
       The range of X values to read in.  The default is to read the entire
       X range of the data
   YRANGE=[ystart, ystop]
       The range of Y values to read in.  The default is to read the entire
       Y range of the data
   ZRANGE=[zstart, zstop]
       The range of Z values to read in.  The default is to read the entire
       Z range of the data

 OUTPUTS:
   This function returns a 3-D 8-bit unsigned array.  The dimensions are
   NX, NY, NZ

 KEYWORD OUTPUTS:
   HEADER=header
       A structure of type {phantom_header} containing the file header.  This structure
       is defined as:
          {phantom_header, $
              cineHeader: {phantom_cine_header}, $
              bitmapInfo: {phantom_bitmap_info}, $
              cameraSetup: {phantom_camera_setup} $
          }
       These structures are all defined in the file phantom_header__define.pro


 RESTRICTIONS:
   There are some fields in the phantom_camera_setup structure that are not described in the 
   documentation we have, and so are not being read correctly.
   This routine will currently only work on little-endian machines like Intel, since I have
   not added byte-swapping yet.

 EXAMPLE:
 IDL> data = read_phantom('BMD_30mm_60mmh_1.cin', header=header) 
 IDL> help, data
 DATA            BYTE      = Array[800, 600, 831]
 IDL> help, /structure, header             
 ** Structure PHANTOM_HEADER, 3 tags, length=1048, data length=1040:
    CINEHEADER      STRUCT    -> PHANTOM_CINE_HEADER Array[1]
    BITMAPINFO      STRUCT    -> PHANTOM_BITMAP_INFO Array[1]
    CAMERASETUP     STRUCT    -> PHANTOM_CAMERA_SETUP Array[1]
 
 IDL> help, /structure, header.cineheader
 ** Structure PHANTOM_CINE_HEADER, 12 tags, length=44, data length=44:
   TYPE            UINT         18755
   HEADERSIZE      UINT            44
   COMPRESSION     UINT             0
   VERSION         UINT             1
   FIRSTMOVIEIMAGE LONG             -2939
   TOTALIMAGECOUNT ULONG             2940
   FIRSTIMAGENO    LONG             -2286
   IMAGECOUNT      ULONG              831
   OFFIMAGEHEADER  ULONG               44
   OFFSETUP        ULONG               84
   OFFIMAGEOFFSETS ULONG            11576
   TRIGGERTIME     STRUCT    -> PHANTOMTIME64 Array[1]

 The cineHeader tells how many frames were captured (2940), the total number that were saved 
 to disk (831), the index of the first captured frame relative to the trigger (-2939), 
 and the index of the first saved frame relative to the trigger (-2286).  It also contains 
 information on where the data are located in the file.
  
 IDL> help, /structure, header.bitmapinfo
 ** Structure PHANTOM_BITMAP_INFO, 11 tags, length=40, data length=40:
   BISIZE          ULONG               40
   BIWIDTH         LONG               800
   BIHEIGHT        LONG               600
   BIPLANES        UINT             1
   BIBITCOUNT      UINT             8
   BICOMPRESSION   ULONG                0
   BISIZEIMAGE     ULONG           480000
   BIXPELSPERMETER LONG             45454
   BIYPELSPERMETER LONG             45454
   BICLRUSED       ULONG                0
   BICLRIMPORTANT  ULONG                0

 The bitmapHeader give the dimension of each frame, the how many bits, etc.

 IDL> help, /structure, header.camerasetup
 ** Structure PHANTOM_CAMERA_SETUP, 87 tags, length=964, data length=956:
   FRAMERATE16     UINT          4800
   SHUTTER16       UINT           125
   POSTTRIGGER16   UINT             1
   FRAMEDELAY16    UINT             0
   ASPECTRATIO     UINT             1
   CONTRASTP       UINT             0
   BRIGHTP         UINT             0
   ROTATEP         BYTE         0
   TIMEANNOTATION  BYTE         1
   TRIGCINE        BYTE         1
   TRIGFRAME       BYTE         0
   SHUTTERON       BYTE         1
   DESCRIPTION     BYTE      Array[121]
   MARK            UINT         21587
   LENGTH          UINT          1504
   BINNING         UINT             1
   BINENABLE       UINT             0
   BINCHANNELS     INT              0
   BINSAMPLES      BYTE         1
   BINNAME         BYTE      Array[11, 8]                   
...

 MODIFICATION HISTORY:
   Written by: Mark Rivers, March 5, 2005
</PRE><P>
<STRONG>(See read_phantom.pro)</STRONG><P>
<HR>
 
<A NAME="READ_PHOTOMETRICS">
<H2>READ_PHOTOMETRICS</H2></A>
<A HREF="#READ_PHANTOM">[Previous Routine]</A>
<A HREF="#READ_PRINCETON">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_PHOTOMETRICS

 PURPOSE:
   This procedures reads a Photometrics image proicessing format file (PMIS).

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   READ_PHOTOMETRICS, File, Header, Data

 INPUTS:
   File:  
       The name of the Photometrics PMIS input file.

 OUTPUTS:
   Header:  
       A structure which contains the header information.
       The names of the fields in this structure are meant to be
       self-explanatory.

   Data:  
       The 2-D array of intensities.  This is a 16-bit INT array

 EXAMPLE:
   READ_PHOTOMETRICS, 'Myfile.pmis', header, data

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, 1993?
   Modifications:
       MLR 26-APR-1999 Added documentation header
</PRE><P>
<STRONG>(See read_photometrics.pro)</STRONG><P>
<HR>
 
<A NAME="READ_PRINCETON">
<H2>READ_PRINCETON</H2></A>
<A HREF="#READ_PHOTOMETRICS">[Previous Routine]</A>
<A HREF="#READ_PXL">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_PRINCETON

 PURPOSE:
   This procedure reads data files written by Princeton Instruments'
   WinSPEC and WinVIEW software.

 CATEGORY:
   File input.

 CALLING SEQUENCE:
   READ_PRINCETON, File, Data

 INPUTS:
   File:
       The name of the data file to read.

 OUTPUTS:
   Data[nx, ny, nframes]:
   The output data array.  The array will be 1, 2 or 3 dimensions
   (depending upon whether ny and nframes are 1) and can be integer,
   long or float data type.

 KEYWORD OUTPUTS:
   HEADER:
       The 4100 byte header from the file.  This header can be used to
       extract additional information about the file.  See the Princteon
       Instruments "PC Interface Library Programming Manual" for the
       description of the header structure, and this procedure for
       examples of how to extract information from the header.

   X_CALIBRATION:
       An nx array of calibrated values for each pixel in the X direction.
   Y_CALIBRATION:
       An ny array of calibrated values for each pixel in the Y direction.
   COMMENTS:
       A 5-element string array containing the "experiment comments"
       fields, which is a 5x80 byte array starting at location 200 in
       the PI header.  These fields are typically used to store
       experiment-specific information.  For example, in the tomography
       experiments we use the first two strings to store the frame type
       and rotation angle.
   DATE:
       A date string of the form DDMMMYYYY:HH:MM:SS
   EXPOSURE:
       The exposure time in seconds.
   BACKGROUND_FILE:
       The name of the background file that was subtracted from the data

 RESTRICTIONS:
   This procedure currently only extracts limited information from the
   header. It should be exhanced to extract more fields, probably into a
   structure.
   The data and calibration are corrected for byte order when reading on
   a big-endian host, but other elements of the header are not converted.

 EXAMPLE:
   Read a data file:

       IDL> READ_PRINCETON, 'test.spe', data, header=header, x_cal=x_cal
       IDL> plot, x_cal, data
       IDL> clock_speed = float(header, 1428)
       IDL> print, 'Vertical clock speed (microseconds) = ', clock_speed

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, 11/4/97
   Mark Rivers 10/27/98  Convert data to long if any pixels are > 32K
   Mark Rivers 11/12/98  Fix to not convert data if already long
   Mark Rivers 3/16/99   Added /BLOCK keyword to openr to work with VMS
   Mark Rivers 3/27/99   Added "Comments" keyword
   Mark Rivers 3/29/99   Added "Date" keyword
   Mark Rivers 2/22/00   Corrected byte order for data and calibration.
   Mark Rivers 9/11/01   Added "exposure" keyword
   Mark Rivers 9/12/01   Added "background_file" keyword
   Mark Rivers 5/28/13   Added support for V3.x SPE files with XML footer
</PRE><P>
<STRONG>(See read_princeton.pro)</STRONG><P>
<HR>
 
<A NAME="READ_PXL">
<H2>READ_PXL</H2></A>
<A HREF="#READ_PRINCETON">[Previous Routine]</A>
<A HREF="#READ_SIEMENS">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_PXL

 PURPOSE:
   This procedures reads a Photometrics PXL image processing format file

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   READ_PXL, File, Header, Data

 INPUTS:
   File:
       The name of the Photometrics PXL input file.

 OUTPUTS:
   Header:
       A structure which contains the header information.
       The names of the fields in this structure are meant to be
       self-explanatory.

   Data:
       The 2-D array of intensities.  This is a 16-bit INT array

 EXAMPLE:
   READ_PXL, 'Myfile.pxl', header, data

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, Feb. 20, 2000
</PRE><P>
<STRONG>(See read_pxl.pro)</STRONG><P>
<HR>
 
<A NAME="READ_SIEMENS">
<H2>READ_SIEMENS</H2></A>
<A HREF="#READ_PXL">[Previous Routine]</A>
<A HREF="#READ_WDX">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_SIEMENS

 PURPOSE:
   This procedure reads Siemens (now Bruker) CCD data files written by
   their SMART software.

 CATEGORY:
   Detectors

 CALLING SEQUENCE:
   READ_SIEMENS, File, Header, Data

 INPUTS:
   File:
       The name of the input file to be read.

 OUTPUTS:
   Header:
       A string array [2, 96].  Header[0,i] is a keyword, such as "NROWS"
       or "ANGLES".  Header[1,i] is the value of that keyword parameter,
       such as "512" or "29.9989000    90.0001000     2.2500000   .0000000"

   Data:
       A 2-D LONG array containing the CCD data.

 RESTRICTIONS:
   This procedure requires at least IDL 5.1 because it uses the
   SWAP_IF_LITTLE_ENDIAN keyword to BYTEORDER.

 EXAMPLE:
   READ_SIEMENS, 'Corund13.178', Header, Data

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, 1995?
   MLR 4-FEB-1999  Modified procedure to work with 8-bit data files
   MLR 26-APR-1999 Added documentation header
</PRE><P>
<STRONG>(See read_siemens.pro)</STRONG><P>
<HR>
 
<A NAME="READ_WDX">
<H2>READ_WDX</H2></A>
<A HREF="#READ_SIEMENS">[Previous Routine]</A>
<A HREF="#READ_XMAP_2D">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_WDX

 PURPOSE:
   This procedure reads scan data files written by the "Qualitative Analysis"
   program in the Windows version of Oxford Instruments/Microspec WinSpec 
   software for driving the WDX wavelength spectrometer.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   READ_WDX, File, Energy, Counts, Header

 INPUTS:
   File:  
       The name of the WDX input file.

 OUTPUTS:
   Energy:  
       A 1-D array containing the energy values for each point in the scan.

   Counts:
       A 1-D array containing the counts for each point in the scan.
       
   Header:  
       A structure containing the instrument settings under which the scan
       was collected.  The fields in this structure are meant to be
       self-explanatory.

 RESTRICTIONS:
   This procedure requires at least IDL 5.1 because it uses the
   SWAP_IF_LITTLE_ENDIAN keyword to BYTEORDER.

 PROCEDURE:
   This code is a bit complex because of a deficiency in the point_lun 
   function under Windows.  Under Unix and VMS this procedure could be 
   simpler, because point_lun work correctly, but under Windows it does not.
   The files have an ASCII header, followed by a control-Z, CR, LF, then 
   binary 32-bit integer pairs of (wavelength*10000, counts).

 EXAMPLE:
   READ_WDX, 'Myfile.001', Energy, Counts, Header

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, 1996?
   Modifications:
       MLR 26-APR-1999 Added documentation header
</PRE><P>
<STRONG>(See read_wdx.pro)</STRONG><P>
<HR>
 
<A NAME="READ_XMAP_2D">
<H2>READ_XMAP_2D</H2></A>
<A HREF="#READ_WDX">[Previous Routine]</A>
<A HREF="#READ_XMAP_NETCDF">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_XMAP_2D

 PURPOSE:
   This function reads a series of MCA mapping netCDF files written by the DXP mapping mode software.
   The data are assumed to be 1 file for each row of a 2-D scan, with file names base_name + num + '.nc'.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   Data = READ_XMAP_2D(base_file, nY, $
                       live_time=live_time, real_time=real_time, $
                       triggers=triggers, events=events, $
                       xRange=xRange, yRange=yRange, $
                       channelRange=channelRange, detectorRange=detectorRange)

 INPUTS:
   base_file:
       The base name of the input files. The files are assumed to be named base_file + num + '.nc', where
       num goes from 1 to nY and .nc is the file extension for netCDF files
   nY:
       The number of Y points in the scan, i.e. the number of netCDF mapping files.

 KEYWORD INPUTS:
    xRange:        Used to optionally restrict the returned data to only a specific range of pixels in the 
                   X (fast) direction. The default is to return all pixels in that direction.  
                   Example: xRange=[100,200].
   yRange:         Used to optionally restrict the returned data to only a specific range of pixels in the 
                   Y (slow) direction. The default is to return all pixels in that direction.  
                       Example: yRange=[100,200].
   channelRange:   Used to optionally restrict the returned data to only a specific range of MCA channels.
                   The default is to return all MCAchannels.  This is very useful for extracting the data 
                   for a specific ROI from the data, for example the counts around the Zn K-alpha peak.  
                   Example: channelRange=[680,720].
   detectorRange:  Used to optionally restrict the returned data to only a specific range of detectors.
                   The default is to return all detectors.  
                   Example: detectorRange=[5,5] will return the data for detector 5 only.
 OUTPUTS:
   By default this function returns a 4-D array [nChannels, nDetectors, nX, nY], i.e. the MCA counts for 
   each detector, at each X and Y pixel in the scan.  This can be an enormous amount of data!  
   The amount of data returned by the function can be restricted with the input keywords described above.

 KEYWORD OUTPUTS:
   live_time:  The live time for each detector at each pixel in the scan
   real_time:  The real time for each detector at each pixel in the scan
   triggers :  The number of triggers (input counts) for each detector at each pixel in the scan
   events:     The number of events (output counts) for each detector at each pixel in the scan

 EXAMPLE:
   The following is an IDL program that calls read_xmap_2d for a 501x500 scan of a Ni mesh.  
   It extracts the Ni Ka peak (channels 716 to 776) from the data.  
   It sums over all the channels in this region, normalizes by live time, sums over all 7 detectors, and 
   finally displays the image with the IDL iTools iimage procedure.
       ; Read data, only channels 716 to 776
       d = read_xmap_2d('Scan4_', 501, live_time=live_time, real_time=real_time, events=events, $
                        triggers=triggers, channel=[716,776])
       ; Sum over channels 716 to 776 (first dimension)
       tot = total(d, 1)
       ; Divide by live time for each detector for each pixel, but live=0 increase to .001
       tot1 = tot/(live_time>.001)
       ; Sum over the detectors
       tot2 = total(tot1, 1)
       ; Display
       iimage, tot2
   end

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, September 2010

</PRE><P>
<STRONG>(See read_xmap_2d.pro)</STRONG><P>
<HR>
 
<A NAME="READ_XMAP_NETCDF">
<H2>READ_XMAP_NETCDF</H2></A>
<A HREF="#READ_XMAP_2D">[Previous Routine]</A>
<A HREF="#WINX32_CCD::BUSY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   READ_XMAP_NETCDF

 PURPOSE:
   This function reads a netCDF file written by the NDPluginFile plugin in the areaDetector module
   containing mapping mode data from the XIA xMAP or Mercury modules.

   This function simply calls <a href=#READ_ND_NETCDF>READ_ND_NETCDF</a>, and then calls <a href=#DECODE_XMAP_BUFFERS>DECODE_XMAP_BUFFERS</a>.  
   It returns the structure returned by <a href=#DECODE_XMAP_BUFFERS>DECODE_XMAP_BUFFERS</a>.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   Data = READ_XMAP_NETCDF(File, Range=Range)

 INPUTS:
   File:
       The name of the input file.  If this argument is missing then the dialog_pickfile() function
       will be called to produce a file browser to select a file interactively.

 KEYWORD INPUTS:
  Range:
       This keyword is simply passed to READ_ND_NETCDF.  
       See the documentation for that function for detailed information.

 OUTPUTS:
       This function returns the structure returned by DECODE_XMAP_BUFFERS.  
       See the documentation for that function for detailed information.

 EXAMPLE:
   This is an example of decoding the buffers for MCA mapping mode data:
   IDL> d = read_xmap_netcdf('mca_mapping_001.nc')
   IDL> help, /structure, d
   ** Structure XMAPDATA, 7 tags, length=28, data length=28:
      FIRSTPIXEL      LONG                 0
      NUMPIXELS       LONG              1000
      PDATA           POINTER   <PtrHeapVar3>
      PREALTIME       POINTER   <PtrHeapVar4>
      PLIVETIME       POINTER   <PtrHeapVar5>
      PINPUTCOUNTS    POINTER   <PtrHeapVar6>
      POUTPUTCOUNTS   POINTER   <PtrHeapVar7>

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, July 2010
</PRE><P>
<STRONG>(See read_xmap_netcdf.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::BUSY">
<H2>WINX32_CCD::BUSY</H2></A>
<A HREF="#READ_XMAP_NETCDF">[Previous Routine]</A>
<A HREF="#WINX32_CCD::CLOSEDOCFILE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::busy

 PURPOSE:
       This function returns the busy status of the WINX32_CCD object. 1 means the controller
       is busy exposing or reading out, 0 means the controller is idle.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       busy = ccd->busy()

 INPUTS:
       None:

 OUTPUTS:
       This function returns the busy status of the controller,  1 means the controller
       is busy exposing or reading out, 0 means the controller is idle.
;
 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       busy = ccd->busy()

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::CLOSEDOCFILE">
<H2>WINX32_CCD::CLOSEDOCFILE</H2></A>
<A HREF="#WINX32_CCD::BUSY">[Previous Routine]</A>
<A HREF="#WINX32_CCD::DOCFILEVALID">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::closeDocFile

 PURPOSE:
       This function closes the current DocFile for the WINX32_CCD object. This has the effect of
       closing the image window in WinView/WinSpec and freeing the DocFile resources.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->closeDocFile()

 INPUTS:
       None

 OUTPUTS:
       This function returns the status of the command, typically 0 for success, -1 for failure.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->closeDocFile()

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::DOCFILEVALID">
<H2>WINX32_CCD::DOCFILEVALID</H2></A>
<A HREF="#WINX32_CCD::CLOSEDOCFILE">[Previous Routine]</A>
<A HREF="#WINX32_CCD::GETDATA">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::docfileValid

 PURPOSE:
       This function returns 1 if there is a valid docFile open with the current
       WINX32_CCD object, and 0 if there is no valid docFile.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       valid = ccd->docfileValid()

 INPUTS:
       None

 OUTPUTS:
       This function returns 1 if there is a valid docFile open with the current
       WINX32_CCD object, and 0 if there is no valid docFile.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       valid = ccd->docfileValid()

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::GETDATA">
<H2>WINX32_CCD::GETDATA</H2></A>
<A HREF="#WINX32_CCD::DOCFILEVALID">[Previous Routine]</A>
<A HREF="#WINX32_CCD::GETDOCFILEPROPERTY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::getData

 PURPOSE:
       This function returns the data for a single frame from the WINX32_CCD object.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->getData(Data)

 INPUTS:
       None:

 OUTPUTS:
       Data:
           The data for the frame.

       This function returns the status of the command, typically 0 for success and -1 for
       for failure.

 KEYWORD PARAMETERS:
   FRAME:  The frame number to return.  Default=1.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->getData(data, frame=100)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::GETDOCFILEPROPERTY">
<H2>WINX32_CCD::GETDOCFILEPROPERTY</H2></A>
<A HREF="#WINX32_CCD::GETDATA">[Previous Routine]</A>
<A HREF="#WINX32_CCD::GETEXPCMDPROPERTY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::getDocFileProperty

 PURPOSE:
       This function gets a single DocFile property of the WINX32_CCD object.  Note that for
       the most commonly read properties the function WINX32_CCD::getProperty can be used
       instead of this function.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->getDocFileProperty(Property, Value)

 INPUTS:
       Property:
           The property to return.  This is an integer value, which is typically obtained
           as a member of the structure type {WINX32_DM_CMD}.

 OUTPUTS:
       Value:
           The value of the property.  The data type of the value will depend on the property
           being read.

       This function returns the status of the command, typically 0 for success and -1 for
       for failure.
;
 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       dm_cmd = WINX32_DM_CMD_INIT()
       status = ccd->getDocFileProperty(dm_cmd.DM_USERCOMMENT1, comment1)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::GETEXPCMDPROPERTY">
<H2>WINX32_CCD::GETEXPCMDPROPERTY</H2></A>
<A HREF="#WINX32_CCD::GETDOCFILEPROPERTY">[Previous Routine]</A>
<A HREF="#WINX32_CCD::GETPROPERTY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::getExpCmdProperty

 PURPOSE:
       This function gets a single ExpCmd property of the WINX32_CCD object.  Note that for
       the most commonly read properties the function WINX32_CCD::getProperty can be used
       instead of this function.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->getExpCmdProperty(Property, Value)

 INPUTS:
       Property:
           The property to returned.  This is an integer value, which is typically obtained
           as a member of the structure type {WINX32_EXP_CMD}.

 OUTPUTS:
       Value:
           The current value of the property.  The data type of the value will depend on the property
           being read.

       This function returns the status of the command, typically 0 for success and -1 for
       for failure.
;
 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       exp_cmd = WINX32_EXP_CMD_INIT()
       status = ccd->getExpCmdProperty(exp_cmd.EXP_EXPOSURE, exposure_time)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::GETPROPERTY">
<H2>WINX32_CCD::GETPROPERTY</H2></A>
<A HREF="#WINX32_CCD::GETEXPCMDPROPERTY">[Previous Routine]</A>
<A HREF="#WINX32_CCD::INIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::getProperty

 PURPOSE:
       This function gets one or more properties of the WINX32_CCD object.   Note that this
       keyword driven function only allows reading the most commonly used properties.
       The functions WINX32_CCD::getExpCmdProperty and WINX32_CCD:getDocFileProperty can be used
       to get any property.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->getProperty()

 INPUTS:
       None

 OUTPUTS:
       This function returns the status of the command, typically 0 for success and -1 for
       for failure.

 KEYWORD PARAMETERS:
   EXPOSURE_TIME:  The exposure time in seconds.
   NFRAMES:        The number of frames to be collected with a single call to WINX32_CCD::Start
   TIMING_MODE:    The timing mode.  1=Free run, 3=External trigger.
   FILE_NAME:      The name of the data file for this image.
   FILE_INCREMENT_COUNT: The next file number if file increment is enabled.
   FILE_INCREMENT_ENABLE: Set to 1 to enable automatic file incrementing, 0 to disable.
   CONTROLLER_NAME: The type of controller.  Note that this is actually a number, not a string.
       0 = "No Controller"
       1 = "ST143"
       2 = "ST130"
       3 = "ST138"
       4 = "VICCD BOX"
       5 = "PentaMax"
       6 = "ST120_T1"
       7 = "ST120_T2"
       8 = "ST121"
       9 = "ST135"
      10 = "ST133"
      11 = "VICCD"
      12 = "ST116"
      13 = "OMA3"
      14 = "LOW_COST_SPEC"
      15 = "MICROMAX"
      16 = "SPECTROMAX"
      17 = "MICROVIEW"
      18 = "ST133_5MHZ"
      19 = "EMPTY_5MHZ"
      20 = "EPIX_CONTROLLER"
      21 = "PVCAM"
      22 = "GENERIC"
      23 = "ARC_CCD_100"
      24 = "ST133_2MHZ"
   COMMENTS:       An string array of 5 elements containing comments for the data file header.                   data file.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->getProperty(exposure_time=exposure_time, timing_mode=timing_mode,$
                                 file_name=file_name, controller_name=controller_name)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::INIT">
<H2>WINX32_CCD::INIT</H2></A>
<A HREF="#WINX32_CCD::GETPROPERTY">[Previous Routine]</A>
<A HREF="#WINX32_CCD::SAVE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::INIT

 PURPOSE:
       This is the initialization code which is invoked when a new object of
       type WINX32_CCD is created.  It cannot be called directly, but only
       indirectly by the IDL OBJ_NEW() function.  It initializes the COM interface
       so that IDL can call the Princeton WINX32 class library under Windows.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       Result = OBJ_NEW('WINX32_CCD')

 INPUTS:
       None

 OUTPUTS:
       This function returns success (1) if it was able to create the EXP_SETUP object in
       the Princeton WINX32 COM interface.  It returns failure (0) if is was unable to create
       this object.

       Typically failure means that the Princeton Instruments WinView or WinSpec software is not
       installed on the machine running IDL.

 RESTRICTIONS:
       This routine cannot be called directly.  It is called indirectly when
       creating a new object of class MCA by the IDL OBJ_NEW() function.

       This function only works on Windows systems that have the Princeton Instruments
       WinView or WinSpec software installed.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->start()

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::SAVE">
<H2>WINX32_CCD::SAVE</H2></A>
<A HREF="#WINX32_CCD::INIT">[Previous Routine]</A>
<A HREF="#WINX32_CCD::SETDOCFILEPROPERTY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::save

 PURPOSE:
       This function saves the data for the WINX32_CCD object.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->save, Filename

 OPTIONAL INPUTS:
       Filename:
           The name of the file to save the data to.  If this input is present then the file
           name is used to set the DM_FILENAME parameter of the current DocFile object before
           saving the file.

 OUTPUTS:
       This function returns the status of the command, typically 0 for success, -1 for failure.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->save('Test1.SPE')

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::SETDOCFILEPROPERTY">
<H2>WINX32_CCD::SETDOCFILEPROPERTY</H2></A>
<A HREF="#WINX32_CCD::SAVE">[Previous Routine]</A>
<A HREF="#WINX32_CCD::SETEXPCMDPROPERTY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::setDocFileProperty

 PURPOSE:
       This function sets a single DocFile property of the WINX32_CCD object.  Note that for
       the most commonly set properties the function WINX32_CCD::setProperty can be used
       instead of this function.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->setDocFileProperty(Property, Value)

 INPUTS:
       Property:
           The property to set.  This is an integer value, which is typically obtained
           as a member of the structure type {WINX32_DM_CMD}.

       Value:
           The value of the property.  The data type of the value will depend on the property
           being set.

 OUTPUTS:
       This function returns the status of the command, typically 0 for success and -1 for
       for failure.
;
 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       dm_cmd = WINX32_DM_CMD_INIT()
       status = ccd->setDocFileProperty(dm_cmd.DM_USERCOMMENT1, "This is comment 1")

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::SETEXPCMDPROPERTY">
<H2>WINX32_CCD::SETEXPCMDPROPERTY</H2></A>
<A HREF="#WINX32_CCD::SETDOCFILEPROPERTY">[Previous Routine]</A>
<A HREF="#WINX32_CCD::SETPROPERTY">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::setExpCmdProperty

 PURPOSE:
       This function sets a single ExpCmd property of the WINX32_CCD object.  Note that for
       the most commonly set properties the function WINX32_CCD::setProperty can be used
       instead of this function.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->setExpCmdProperty(Property, Value)

 INPUTS:
       Property:
           The property to set.  This is an integer value, which is typically obtained
           as a member of the structure type {WINX32_EXP_CMD}.

       Value:
           The value of the property.  The data type of the value will depend on the property
           being set.

 OUTPUTS:
       This function returns the status of the command, typically 0 for success and -1 for
       for failure.
;
 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       exp_cmd = WINX32_EXP_CMD_INIT()
       status = ccd->setExpCmdProperty(exp_cmd.EXP_EXPOSURE, 0.1)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::SETPROPERTY">
<H2>WINX32_CCD::SETPROPERTY</H2></A>
<A HREF="#WINX32_CCD::SETEXPCMDPROPERTY">[Previous Routine]</A>
<A HREF="#WINX32_CCD::START">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::setProperty

 PURPOSE:
       This function sets one or more properties of the WINX32_CCD object.   Note that this
       keyword driven function only allows setting the most commonly used properties.
       The functions WINX32_CCD::setExpCmdProperty and WINX32_CCD:setDocFileProperty can be used
       to set any property.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->setProperty()

 INPUTS:
       None

 OUTPUTS:
       This function returns the status of the command, typically 0 for success and -1 for
       for failure.

 KEYWORD PARAMETERS:
   EXPOSURE_TIME:  The exposure time in seconds.
   NFRAMES:        The number of frames to be collected with a single call to WINX32_CCD::Start
   TIMING_MODE:    The timing mode.  1=Free run, 3=External trigger.
   FILE_NAME:      The name of the data file for this image.
   FILE_INCREMENT_COUNT: The next file number if file increment is enabled.
   FILE_INCREMENT_ENABLE: Set to 1 to enable automatic file incrementing, 0 to disable.
   COMMENTS:       An string array of up to 5 elements containing comments to be put into the
                   data file.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->setProperty(exposure_time=0.1, timing_mode=1, file_name='myfile')

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::START">
<H2>WINX32_CCD::START</H2></A>
<A HREF="#WINX32_CCD::SETPROPERTY">[Previous Routine]</A>
<A HREF="#WINX32_CCD::STOP">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::start

 PURPOSE:
       This function starts data acquisition on the WINX32_CCD object.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->start()

 INPUTS:
       None:

 OUTPUTS:
       This function returns the status of the command, typically 0 for success, -1 for failure.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->start()

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD::STOP">
<H2>WINX32_CCD::STOP</H2></A>
<A HREF="#WINX32_CCD::START">[Previous Routine]</A>
<A HREF="#WINX32_CCD__DEFINE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD::stop

 PURPOSE:
       This function stops data acquisition on the WINX32_CCD object.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       status = ccd->stop()

 INPUTS:
       None:

 OUTPUTS:
       This function returns the status of the command, typically 0 for success, -1 for failure.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->stop()

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006.
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_CCD__DEFINE">
<H2>WINX32_CCD__DEFINE</H2></A>
<A HREF="#WINX32_CCD::STOP">[Previous Routine]</A>
<A HREF="#WINX32_DM_CMD_INIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_CCD__DEFINE

 PURPOSE:
       This is the definition code which is invoked when a new object of
       type WINX32_CCD is created.  It cannot be called directly, but only
       indirectly by the IDL OBJ_NEW() function.  It defines the data
       structures used for the WINX32_CCD class.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       Result = OBJ_NEW('WINX32_CCD')

 INPUTS:
       None

 OUTPUTS:
       None

 RESTRICTIONS:
       This routine cannot be called directly.  It is called indirectly when
       creating a new object of class WINX32_CCD by the IDL OBJ_NEW()
       function.

       This procedure only works on Windows systems that have the Princeton Instruments
       WinView or WinSpec software installed.

 EXAMPLE:
       ccd = obj_new('WINX32_CCD')
       status = ccd->getProperty(exposure_time=exposure_time)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006
</PRE><P>
<STRONG>(See winx32_ccd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_DM_CMD_INIT">
<H2>WINX32_DM_CMD_INIT</H2></A>
<A HREF="#WINX32_CCD__DEFINE">[Previous Routine]</A>
<A HREF="#WINX32_DM_CMD__DEFINE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_DM_CMD_INIT

 PURPOSE:
       This function returns a structure of type {WINX32_DM_CMD} with all of the
       structure members initialized to the integer values for these parameters.

       This structure is used instead of C constants, which are not supported in IDL.

       These values were obtained by opening Microsoft Visual Studio and using
       Tools/OLD/COM Object Viewer.
       Open "Type Libraries/Roper Scienfic's WinX/32 3.6 Type Library/typedef enum DM_CMD.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       dm_cmd = WINX32_DM_CMD_INIT()

 INPUTS:
       None

 OUTPUTS:
       This function returns a structure of type {WINX32_DM_CMD} with all of the
       structure members initialized to the integer values for these parameters.

 EXAMPLE:
       dm_cmd = WINX32_EXP_CMD_INIT()
       ccd = obj_new('WINX32_CCD')
       status = ccd->setProperty(exposure_time=0.1)
       status = ccd->start()
       wait, 1.
       status = ccd->getDocFileProperty(dm_cmd.DM_USERCOMMENT1, comment1)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006
</PRE><P>
<STRONG>(See winx32_dm_cmd_init.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_DM_CMD__DEFINE">
<H2>WINX32_DM_CMD__DEFINE</H2></A>
<A HREF="#WINX32_DM_CMD_INIT">[Previous Routine]</A>
<A HREF="#WINX32_EXP_CMD_INIT">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_DM_CMD__DEFINE

 PURPOSE:
       This is the definition code which is invoked when a new structure of
       type WINX32_DM_CMD is created.  It cannot be called directly, but only
       indirectly by using the IDL automatic structure creation mechanism.
       It defines the data structure for the WINX32_DM_CMD structure type.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       dm_cmd = {WINX32_DM_CMD}

 INPUTS:
       None

 OUTPUTS:
       None

 RESTRICTIONS:
       This routine cannot be called directly.  It is called indirectly when
       creating a new structure of type WINX32_DM_CMD.

       Note that the values in the definition are actually lost when the structure is
       created, all values are set to 0.  The function WINX32_DM_CMD_INIT() should be used
       to create a structure of this type with their values initialized correctly.
;
 EXAMPLE:
       dm_cmd = {WINX32_DM_CMD}
       print, dm_cmd.DM_USERCOMMENT1

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006
</PRE><P>
<STRONG>(See winx32_dm_cmd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_EXP_CMD_INIT">
<H2>WINX32_EXP_CMD_INIT</H2></A>
<A HREF="#WINX32_DM_CMD__DEFINE">[Previous Routine]</A>
<A HREF="#WINX32_EXP_CMD__DEFINE">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_EXP_CMD_INIT

 PURPOSE:
       This function returns a structure of type {WINX32_EXP_CMD} with all of the
       structure members initialized to the integer values for these parameters.

       This structure is used instead of C constants, which are not supported in IDL.

       These values were obtained by opening Microsoft Visual Studio and using
       Tools/OLD/COM Object Viewer.
       Open "Type Libraries/Roper Scienfic's WinX/32 3.6 Type Library/typedef enum EXP_CMD.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       exp_cmd = WINX32_EXP_CMD_INIT()

 INPUTS:
       None

 OUTPUTS:
       This function returns a structure of type {WINX32_EXP_CMD} with all of the
       structure members initialized to the integer values for these parameters.

 EXAMPLE:
       exp_cmd = WINX32_EXP_CMD_INIT()
       ccd = obj_new('WINX32_CCD')
       status = ccd->getExpCmdProperty(exp_cmd.EXP_EXPOSURE, exposure_time)

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006
</PRE><P>
<STRONG>(See winx32_exp_cmd_init.pro)</STRONG><P>
<HR>
 
<A NAME="WINX32_EXP_CMD__DEFINE">
<H2>WINX32_EXP_CMD__DEFINE</H2></A>
<A HREF="#WINX32_EXP_CMD_INIT">[Previous Routine]</A>
<A HREF="#WRITE_BAS2000">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
       WINX32_EXP_CMD__DEFINE

 PURPOSE:
       This is the definition code which is invoked when a new structure of
       type WINX32_EXP_CMD is created.  It cannot be called directly, but only
       indirectly by using the IDL automatic structure creation mechanism.
       It defines the data structure for the WINX32_EXP_CMD structure type.

 CATEGORY:
       IDL device class library.

 CALLING SEQUENCE:
       exp_cmd = {WINX32_EXP_CMD}

 INPUTS:
       None

 OUTPUTS:
       None

 RESTRICTIONS:
       This routine cannot be called directly.  It is called indirectly when
       creating a new structure of type WINX32_EXP_CMD.

       Note that the values in the definition are actually lost when the structure is
       created, all values are set to 0.  The function WINX32_EXP_CMD_INIT() should be used
       to create a structure of this type with their values initialized correctly.
;
 EXAMPLE:
       exp_cmd = {WINX32_EXP_CMD}
       print, exp_cmd.EXP_EXPOSURE

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, November 1, 2006
</PRE><P>
<STRONG>(See winx32_exp_cmd__define.pro)</STRONG><P>
<HR>
 
<A NAME="WRITE_BAS2000">
<H2>WRITE_BAS2000</H2></A>
<A HREF="#WINX32_EXP_CMD__DEFINE">[Previous Routine]</A>
<A HREF="#WRITE_PRINCETON">[Next Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   WRITE_BAS2000

 PURPOSE:
   This procedure writes an 8 bit data file in BAS2000 format. It can then
   be sent to the BAS2000 printer, although colors are a problem.

 CATEGORY:
   Detectors.

 CALLING SEQUENCE:
   WRITE_BAS2000, Data, File

 INPUTS:
   Data:  
       An 8-bit array of data.  The first dimension must be 1024 or 2048
       and the second dimension must be 1280, 2048 or 4096.

   File:
       The name of the output file without the '.inf' or '.img' extensions

 SIDE EFFECTS:
   This procedure creates  File.inf and File.img, which the scanner software
   can then read.

 RESTRICTIONS:
   This routine is really only useful for creating files to be printed on
   the BAS2000 printer, which probably does not even work any more!

 EXAMPLE:
   data = bytscl(dist(256))
   WRITE_BAS2000, data, 'Myfile'

 MODIFICATION HISTORY:
   Written by:     Mark Rivers, 1993?
   Modifications:
       MLR 26-APR-1999 Added documentation header
</PRE><P>
<STRONG>(See write_bas2000.pro)</STRONG><P>
<HR>
 
<A NAME="WRITE_PRINCETON">
<H2>WRITE_PRINCETON</H2></A>
<A HREF="#WRITE_BAS2000">[Previous Routine]</A>
<A HREF="#ROUTINELIST">[List of Routines]</A>
<PRE>
 NAME:
   WRITE_PRINCETON

 PURPOSE:
   This procedure writes data files that can be read by Princeton Instruments'
   WinSPEC and WinVIEW software.

 CATEGORY:
   File input.

 CALLING SEQUENCE:
   WRITE_PRINCETON, File, Data, Header

 INPUTS:
   File:
       The name of the data file to read.
   Data[nx, ny, nframes]:
   The output data array.  The array will be 1, 2 or 3 dimensions
   (depending upon whether ny and nframes are 1) and can be integer,
   long or float data type.

   HEADER:
       The 4100 byte header from the file.  This header can be used to
       extract additional information about the file.  See the Princteon
       Instruments "PC Interface Library Programming Manual" for the
       description of the header structure, and this procedure for
       examples of how to extract information from the header.

 RESTRICTIONS:
   This procedure currently only extracts limited information from the
   header. It should be exhanced to extract more fields, probably into a
   structure.
   The data and calibration are corrected for byte order when reading on
   a big-endian host, but other elements of the header are not converted.

 EXAMPLE:
   Write a data file:

       IDL> READ_PRINCETON, 'test.spe', data, header=header
       IDL> header.comments[2]='
       IDL> clock_speed = float(header, 1428)
       IDL> print, 'Vertical clock speed (microseconds) = ', clock_speed

 MODIFICATION HISTORY:
       Written by:     Mark Rivers, 11/4/97
   Mark Rivers 10/27/98  Convert data to long if any pixels are > 32K
   Mark Rivers 11/12/98  Fix to not convert data if already long
   Mark Rivers 3/16/99   Added /BLOCK keyword to openr to work with VMS
   Mark Rivers 3/27/99   Added "Comments" keyword
   Mark Rivers 3/29/99   Added "Date" keyword
   Mark Rivers 2/22/00   Corrected byte order for data and calibration.
   Mark Rivers 9/11/01   Added "exposure" keyword
   Mark Rivers 9/12/01   Added "background_file" keyword
</PRE><P>
<STRONG>(See write_princeton.pro)</STRONG><P>
<HR>
 
</body>
</html>
